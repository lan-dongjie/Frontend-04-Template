学习笔记

0、广度/深度优先
  1、遍历可扩展点寻路

1、启发式寻路
  1、给寻路扩展点优先级
  2、根据优先级寻路减少寻路次数

2、二叉堆a星寻路算法
  1、二叉堆：完全二叉结构，父节点键值永远小于（大于）子节点键值
  2、每次取根节点寻路，使用二叉堆不减少寻路空间复杂度，只提升效率
  3、进堆上升，出堆下沉，保持根节点小于（大于）子节点键值

3、回到入学测评第五问实现快速排序代码，并且用动画演示它的过程
  1、QuickSort.html

4、抽象语法树（AST）
  1、/([0-9\.]+)|([ \t]+)|([\r\n]+)|(\*)|(\/)|(\+)|(\-)/g
  2、类型：'Number', 'Whiltespace', 'LineTerminator', '*', '/', '+', '-'
  3、exec
    1、如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。
    2、但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。


总结：
  1、寻路算法老师按照老师说的修改指定两个地方还有最短路径没实现；感觉要找出这个路径需要提升计算复杂度，得不偿失。
  2、AST还是有点难理解，加上正则也不太懂，目前这部分还是没法随机应变，感觉可以在知识体系里面添加一个正则主题